# 「BUAA-CO」P0-Offline

> 2023年P0课下题目及我的5A答案

文件在我的 GitHub

## 1.P0_L0_FSM

### 正则表达式匹配

正则表达式是对字符串操作的一种逻辑公式，它通常被用来检索、替换符合某个模式的文本。它的规则比较复杂，我们现在只讲解其中比较简单的几种规则。

- [...]是指要匹配中括号中的字符(注意是字符不是字符串),比如[xyz]就是要匹配x y z这三个字符中的任意一个。
- {...}是指要求匹配”{“前的那个字符几次，比如a{2}是指要匹配a两次，a{2,4}是指要匹配a 2至4次,a{,4}指要匹配a 0至4次，a{2,}指要匹配a 2至无穷次。所以[cd]{1,2}就是要求匹配(c或d)一次或两次,即cc、dd、cd、dc、c、d都是能匹配的。
- (...)是指将()内的字符串视为一个整体，比如(ab){1,2}对应的就是ab或abab。
- 我们也可以将多条表达式组合起来，如a{2}b{2}就是指匹配a两次后再匹配b两次,即匹配aabb。

### 提交要求

使用Logisim搭建一个Mealy型有限状态机 检测串行输入字符串中的能匹配正则表达式b{1,2}[ac]{2}的子串并输出。具体模块端口定义如下：

| 信号名  | 方向 | 描述                                                         |
| ------- | ---- | ------------------------------------------------------------ |
| In[1:0] | I    | 串行方式输入字符串。 为简化电路，我们规定 00 表示 'a'，01 表示 'b'，10 表示 'c'，11 表示其他字符。 |
| CLR     | I    | 清除置位信号                                                 |
| Z       | O    | 输出是否检测到了与表达式匹配的子串 1：检测到了 0：未检测到   |

模块功能定义如下：

| 序号 | 功能     | 功能描述                                                     |
| ---- | -------- | ------------------------------------------------------------ |
| 1    | 置位清零 | 当时钟上升沿到来时，如果清零信号有效，则电路复位至初始状态（无论此时输入信号是什么）（即同步复位） |
| 2    | 状态转移 | 当时钟上升沿到来时，检测输入的字符 In，并根据当前状态以及 In 的值进行适当的状态转移 |
| 3    | 输出     | 当检测到匹配 b{1,2}[ac]{2} 的字符串时，Z 输出为1，否则输出为 0 |

- 必须严格按照模块的端口定义
- 文件内模块名: fsm
- **注意: 每当匹配到一个子串时，需要输出一次1。例如对字符串bacbacac,模块应当在第1个c输入和第2个c输入时输出1,而在其他时刻保持输出为0。**
- **注意：有限状态机的设计是Mealy型有限状态机。**
- 测试电路如下：(code部分是你需要搭建的电路)

![](images/9-3.png)

- **注意:请保证模块的appearance与下图完全一致，否则有可能造成评测错误**

![](images/9-5.png)



### 设计思路

状态表





## 2.P0_L0_CRC

### CRC校验

### 提交要求

使用Logisim搭建一个除数为四位，原数据帧为8位的CRC校验码计算电路。具体模块端口定义如下：

| 信号名  | 方向 | 描述                      |
| ------- | ---- | ------------------------- |
| A[7:0]  | I    | 8 位原数据帧              |
| B[3:0]  | I    | 4 位除数                  |
| C[10:0] | O    | 8 位原数据帧 + 3 位校验码 |

- 必须严格按照模块的端口定义
- 文件内模块名: **CRC**
- 我们规定除数的最高位一定为1,不需要考虑最高位非1的情况
- **注意:由于信号原帧位数为8位，进行除法运算时被除数应为8+3=11位**
- 测试电路：(CRC为你需要搭建的电路)

![](images/499-2.png)

- **注意:请保证模块的appearance与下图完全一致，否则有可能造成评测错误**

![](images/499-4.png)





## 3.P0_L0_GRF

### 实现GRF

## 提交要求

使用logisim搭建一个GRF。

GRF中包含32个32位寄存器，分别对应0~31号寄存器，其中0号寄存器读取的结果恒为0。具体模块端口定义如下：



## 2.noDescendSequence

识别16bit输入从高位到低位每4bit组成的4位序列是否为不下降序列

| 信号       | 方向  | 说明                       |
| ---------- | ----- | -------------------------- |
| data[15:0] | input | 代表4位4bit输入            |
| result     | out   | 输出结果：是否为不下降序列 |



思路：本题**不涉及时序逻辑**，直接取 `data` 的对应位进行比较即可。一行代码我就不贴出来了（



## 3.tetris

模拟8位俄罗斯方块游戏设计 Mealy 状态机

| 信号        | 方向 | 说明                               |
| ----------- | ---- | ---------------------------------- |
| input[7:0]  | I    | 八位独热码，模拟掉落一个俄罗斯方块 |
| reset       | I    | **异步复位**                       |
| clk         | I    | 时钟信号                           |
| output[1:0] | O    | 输出状态                           |

reset为**异步复位**，当reset为高电平时，状态恢复到一开始状态

状态：输出01表示输入位置已有方块，放置无效，保持原状态

输出10表示有效放置

输出11表示消去一行



### 思路

**第一步也是最重要的一步，确定状态机类型。一时不慎，满盘皆输！！！**

方块的摆放情况数为 8 位二进制数的数量 $2^8$，再考虑每次独热码输入有 8 种，**有效的**状态转移真值表共约 $8 \times 2^8$ 行，再考虑到无效的状态转移行，故采用真值表刻画状态转移的方式应该不是题目意图~~（当然如果你毅力超群，我致以崇高敬意）~~。我采取的方案是用当前的方块摆放情况表示状态，在 Mealy 状态机的输出模块再转换成 `output[1:0]`

放置方块的行为让我联想到二进制的按位运算。判断某位是否已有方块，只需将输入和当前方块**按位与**，结果非 0 即为无效放置。而更新状态，只需将输入和当前方块放置状态**按位或**，注意**特判**放满后清空即可。

### Tips

注意到 logisim 中寄存器初值为 0，所以不用进行寄存器的初始化。

注意判断**复位方式**是同步复位还是异步复位。异步复位在 logisim 中的实现较为简单。

此外，注意判断**时钟**是输入还是自带信号。

还有一件事~~（成龙历险记老爹音）~~，题目要求的电路外观似乎不同于三输入一输出的默认外观，只需将左边三输入向下移动一格即可，外观的线不是很重要。

电路外观如图（已隐去部分内容）





最后，祝大家上机顺利，学有所获！