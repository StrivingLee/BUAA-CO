# P6 设计文档

[TOC]

# 设计草稿

## 一、设计与测试说明

1. 处理器为 32 位五级流水线处理器

2. 支持延迟槽

3. 支持如下指令集：

   ```mipsasm
   add, sub, and, or, slt, sltu, lui
   addi, andi, ori
   lb, lh, lw, sb, sh, sw
   mult, multu, div, divu, mfhi, mflo, mthi, mtlo
   beq, bne, jal, jr
   ```

   请注意，所有运算类指令均暂不考虑因溢出而产生的异常。

5. 采用全速转发的设计

6. 转发的数据来源为流水线寄存器

7. 采用模块化和层次化设计，顶层文件为 mips.v，接口定义如下：

   ```verilog
   module mips(
       input clk,
       input reset,
       input [31:0] i_inst_rdata,
       input [31:0] m_data_rdata,
       output [31:0] i_inst_addr,
       output [31:0] m_data_addr,
       output [31:0] m_data_wdata,
       output [3 :0] m_data_byteen,
       output [31:0] m_inst_addr,
       output w_grf_we,
       output [4:0] w_grf_addr,
       output [31:0] w_grf_wdata,
       output [31:0] w_inst_addr
   );
   ```





## 二、整体结构

### 1.模块规格

- IFU
  - 端口说明
  
    | 序号 |     信号名      | 方向 |                            描述                            |
    | :--: | :-------------: | :--: | :--------------------------------------------------------: |
    |  1   |       clk       |  I   |                          时钟信号                          |
    |  2   |      reset      |  I   |          同步复位信号<br>1'b1：清零<br>1'b0：保持          |
    | 3 | en | I | IM 使能信号 |
    |  4   | NPC[31:0] | I | 32 位当前指令计数，接收 NPC 的 NPC 信号 |
    |  5   |     PC[31:0]     |  O   |          输出 PC 信号           |
    
  - 功能定义
  
    | 序号 |   功能   |                   描述                    |
    | :--: | :------: | :---------------------------------------: |
    |  1   | 同步复位 | reset 信号为 1'b1 时，置 PC 为 0x00003000 |
    |  2   | 输出 PC  |             输出当前指令计数              |




- D_REG

    - 端口说明
    
      | 序号 |    信号名     | 方向 |                   描述                   |
      | :--: | :-----------: | :--: | :--------------------------------------: |
      |  1   |      clk      |  I   |                 时钟信号                 |
      |  2   |     reset     |  I   | 同步复位信号<br>1b'1：清零<br>1'b0：保持 |
      |  3   |      en       |  I   |                 使能信号                 |
      |  4   |  F_PC[31:0]   |  I   |               F 级指令计数               |
      |  5   | F_Instr[31:0] |  I   |                 F 级指令                 |
      |  6   |  D_PC[31:0]   |  O   |               D 级指令计数               |
      |  7   | D_Instr[31:0] |  O   |                 D 级指令                 |

    - 功能定义
    
      | 序号 |       功能       | 描述 |
      | :--: | :--------------: | :--: |
      |  1   | 传递 PC 和 Instr |  -   |



- NPC

  - 端口说明

    | 序号 |     信号名     | 方向 |                         描述                          |
    | :--: | :------------: | :--: | :---------------------------------------------------: |
    |  1   |      Zero      |  I   |                 ALU 运算结果是否为 0                  |
    |  2   |  GreaterZero   |  I   | SrcA 是否 > 0的标志信号，接收 ALU 的 GreaterZero 信号 |
    |  3   |      beq       |  I   |                  当前指令是否为 beq                   |
    |  4   |      bne       |  I   |                  当前指令是否为 bne                   |
    |  4   |      bgtz      |  I   |                  当前指令是否为 bgtz                  |
    |  5   |      jal       |  I   |                  当前指令是否为 jal                   |
    |  6   |       jr       |  I   |                   当前指令是否为 jr                   |
    |  7   |   F_PC[31:0]   |  I   |                    接收 F_PC 信号                     |
    |  8   |   D_PC[31:0]   |  I   |                    接收 D_PC 信号                     |
    |  8   |  Imm26[25:0]   |  I   |              接收 Splitter 的 Imm26 信号              |
    |  9   | EXTImm32[31:0] |  I   |               接收 EXT 的 EXTImm32 信号               |
    |  10  | GRF[rs]\[31:0] |  I   |                   接收 GRF[rs] 的值                   |
    |  11  |   NPC[31:0]    |  O   |                Next PC，下一条指令计数                |
  
  - 功能定义
  
    | 序号 |   功能   |          描述           |
    | :--: | :------: | :---------------------: |
    |  1   | 计算 NPC | 根据NPCControl 计算 NPC |



- CMP

  - 端口说明

    | 序号 |   信号名   | 方向 |     描述     |
    | :--: | :--------: | :--: | :----------: |
    |  1   | SrcA[31:0] |  I   | 第一个计算数 |
    |  2   | SrcB[31:0] |  I   | 第二个计算数 |
    |  3   |    Zero    |  I   |     相等     |
    |  4   |     GZ     |  O   |    A > B     |
    |  5   |     LZ     |  O   |    A < B     |

  - 功能定义

    | 序号 | 功能 |          描述          |
    | :--: | :--: | :--------------------: |
    |  1   | 比较 | 比较 SrcA 与 SrcB 大小 |



- GRF

  - 端口说明

    | 序号 | 信号名 | 方向 | 描述 |
    | :----: | :------: | :----: | :----: |
    | 1    | clk    | I    | 时钟信号 |
    | 2 | reset | I | 同步复位信号<br>1b'1：清零<br>1'b0：保持 |
    | 3 | RegWrite | I | 写使能信号，接受 RegWrite <br>1'b1：可写入数据<br>1'b0：不可写入数据 |
    | 4 | A1[4:0] | I | 5 位地址位选信号，接收 rs |
    | 5 | A2[4:0] | I | 5 位地址位选信号，接收 rt |
    | 6 | RegAddr[4:0] | I | 5 位地址位选信号，选择写入的寄存器 |
    | 7 | RegData[31:0] | I | 32 位写入数据 |
    | 8 | PC[31:0] | I | 当前指令计数 |
    | 9 | RD1[31:0] | O | 输出 GRF[rs] |
    | 10 | RD2[31:0] | O | 输出 GRF[rt] |
    
  - 功能定义

    | 序号 | 功能 | 描述 |
    | :----: | :----: | :----: |
    | 1 | 同步复位 | reset 信号为 1'b1 时，将所有寄存器清空为 32'b0 |
    | 2 | 读寄存器 | 将 A1 和 A2 对应的寄存器中的值输出到 RD1 和 RD2 |
    | 3 | 写寄存器 | RegWrite 为 1'b1 且 RegAddr 不为 5'b0 时，在时钟上升沿将 RegData 的值写入到 RegAddr 对应的寄存器中 |
    

.


- EXT

  - 端口说明

    | 序号 |     信号名      | 方向 |                             描述                             |
    | :--: | :-------------: | :--: | :----------------------------------------------------------: |
    |  1   |   Imm16[15:0]   |  I   |                    16 位需要扩展的立即数                     |
    |  2   | EXTControl[1:0] |  I   | 符号扩展的标志信号<br>接收 Controller 产生的 EXTControl 信号<br>2'b00：零扩展<br>2'b01：符号扩展<br>2'b10：低位零扩展 |
    |  3   | EXTResult[31:0] |  O   |                        32 位扩展结果                         |

  - 功能定义

    | 序号 |     功能     | 描述 |
    | :--: | :----------: | :--: |
    |  1   | 高位符号扩展 |  -   |
    |  2   |  高位零扩展  |  -   |
    |  3   |  低位零扩展  |  -   |

.


- E_REG

    - 端口说明
    
      | 序号 |      信号名       | 方向 |                   描述                   |
      | :--: | :---------------: | :--: | :--------------------------------------: |
      |  1   |        clk        |  I   |                 时钟信号                 |
      |  2   |       reset       |  I   | 同步复位信号<br>1b'1：清零<br>1'b0：保持 |
      |  3   |        clr        |  I   |                 清空信号                 |
      |  4   |    D_PC[31:0]     |  I   |               D 级指令计数               |
      |  5   |   D_Instr[31:0]   |  I   |                 D 级指令                 |
      |  6   |    D_WD1[31:0]    |  I   |               D 级 GPR[rs]               |
      |  7   |    D_WD2[31:0]    |  I   |               D 级 GPR[rt]               |
      |  8   | D_EXTResult[31:0] |  I   |              D 级 EXT 结果               |
      |  9   |    E_PC[31:0]     |  O   |               E 级指令计数               |
      |  10  |   E_Instr[31:0]   |  O   |                 E 级指令                 |
      |  11  |    E_WD1[31:0]    |  O   |               E 级 GPR[rs]               |
      |  12  |    E_WD1[31:0]    |  O   |               E 级 GPR[rs]               |
      |  13  | E_EXTResult[31:0] |  O   |              E 级 EXT 结果               |

    - 功能定义
    
      | 序号 |                功能                 | 描述 |
      | :--: | :---------------------------------: | :--: |
      |  1   | 传递 Instr、PC、WD1、WD2、EXTResult |  -   |




- ALU

  - 端口说明

    | 序号 | 信号名 | 方向 | 描述 |
    | :----: | :------: | :----: | :----: |
    | 1 | SrcA[31:0] | I | 第一个运算数 |
    | 2 | SrcB[31:0] | I | 第二个运算数 |
    | 3 | ALUControl[2:0] | I | ALU 控制信号，对应的操作为：<br>3'b000：+<br>3'b001：-<br>3‘b010：\^（按位异或）<br>3'b011：\|（按位）<br>3'b100：<<（左移） |
    | 4 | shamt[4:0] | I | - |
    | 5 | ALUResult[31:0] | O | SrcA 与 SrcB 运算结果 |
    
  - 功能定义
    | 序号 |      功能      |                    描述                     |
    | :--: | :------------: | :-----------------------------------------: |
    |  1   |      加法      |        输出 SrcA + SrcB 到 ALUResult        |
    |  2   |      减法      |        输出 SrcA - SrcB 到 ALUResult        |
    |  3   |     按位与     |        输出 SrcA & SrcB 到 ALUResult        |
    |  4   |     按位或     |       输出 SrcA \| SrcB 到 ALUResult        |
    |  5   |    按位异或    |        输出SrcA ^ SrcB 到 ALUResult         |
    |  6   |      左移      |       输出 SrcA << shamt 到 ALUResult       |
    |  7   | 有符号小于置 1 | 当 SrcA < SrcB（有符号），置 ALUResult 为 1 |
    |  8   | 无符号小于置 1 | 当 SrcA < SrcB（无符号），置 ALUResult 为 1 |
    




- MDU

  - 端口说明

    | 序号 |     信号名      | 方向 |                    描述                    |
    | :--: | :-------------: | :--: | :----------------------------------------: |
    |  1   |       clk       |  I   |                  时钟信号                  |
    |  2   |      reset      |  I   | 同步复位信号<br/>1b'1：清零<br/>1'b0：保持 |
    |  3   | MDUControl[3:0] |  I   |               MDU 的控制信号               |
    |  4   |   SrcA[31:0]    |  I   |                第一个运算数                |
    |  5   |   SrcB[31:0]    |  I   |                第二个运算数                |
    |  6   |      Start      |  I   |                                            |
    |  7   |      Busy       |  O   |                  是否“忙”                  |
    |  8   |    HI[31:0]     |  O   |                                            |
    |  9   |    LO[31:0]     |  O   |                                            |
  
  - 功能定义
  
    | 序号 |    功能    | 描述 |
    | :--: | :--------: | :--: |
    |  1   | 乘除法运算 |      |
    |      |            |      |
    |      |            |  -   |




- M_REG

    - 端口说明
    
      | 序号 |      信号名       | 方向 |                   描述                   |
      | :--: | :---------------: | :--: | :--------------------------------------: |
      |  1   |        clk        |  I   |                 时钟信号                 |
      |  2   |       reset       |  I   | 同步复位信号<br>1b'1：清零<br>1'b0：保持 |
      |  3   |        clr        |  I   |                 清空信号                 |
      |  4   |    E_PC[31:0]     |  I   |               E 级指令计数               |
      |  5   |   E_Instr[31:0]   |  I   |                 E 级指令                 |
      |  6   |    E_WD2[31:0]    |  I   |               E 级 GPR[rt]               |
      |  7   | E_ALUResult[31:0] |  I   |              E 级 ALU 结果               |
      |  8   | E_EXTResult[31:0] |  I   |              E 级 EXT 结果               |
      |      |    E_HI[31:0]     |  I   |                 E 级 HI                  |
      |      |    E_LO[31:0]     |  I   |                 E 级 LO                  |
      |  9   |    M_PC[31:0]     |  O   |               M 级指令计数               |
      |  10  |   M_Instr[31:0]   |  O   |                 M 级指令                 |
      |  11  |    M_WD2[31:0]    |  O   |               M 级 GPR[rt]               |
      |  12  | M_ALUResult[31:0] |  O   |              M 级 ALU 结果               |
      |  13  | M_EXTResult[31:0] |  O   |              M 级 EXT 结果               |
      |      |    M_HI[31:0]     |  O   |                 M 级 HI                  |
      |      |    M_LO[31:0]     |  O   |                 M 级 LO                  |
    - 功能定义
    
      | 序号 |                       功能                        | 描述 |
      | :--: | :-----------------------------------------------: | :--: |
      |  1   | 传递 Instr、PC、WD2、ALUResult、EXTResult、HI、LO |  -   |




- W_REG

    - 端口说明
    
      | 序号 |      信号名       | 方向 |                   描述                   |
      | :--: | :---------------: | :--: | :--------------------------------------: |
      |  1   |        clk        |  I   |                 时钟信号                 |
      |  2   |       reset       |  I   | 同步复位信号<br>1b'1：清零<br>1'b0：保持 |
      |  3   |    M_PC[31:0]     |  I   |               M 级指令计数                 |
      |  4   |   M_Instr[31:0]   |  I   |                 M 级指令                 |
      |  5  | M_ALUResult[31:0] |  I   |              M 级 ALU 结果              |
      |  6  | M_EXTResult[31:0] |  I   |              M 级 EXT 结果              |
      | 7 | M_HI[31:0] | I | M 级 HI |
      | 8 | M_LO[31:0] | I | M 级 LO |
      | 9 | M_MemReadData[31:0] | I | M 级 DM 结果 |
      |  10  |    W_PC[31:0]    |  O   |               W 级指令计数               |
      |  11  |   W_Instr[31:0]   |  O   |                 W 级指令                 |
      |  12  | W_ALUResult[31:0] |  O   |              W 级 ALU 结果               |
      |  13  | W_EXTResult[31:0] |  O   |              W 级 EXT 结果               |
      | 14 | W_HI[31:0] | O | W 级 HI |
      | 15 | W_LO[31:0] | O | W 级 LO |
      | 16 | W_MemReadData[31:0] | O | W 级 DM 结果 |
      
    - 功能定义
    
      | 序号 |                             功能                             | 描述 |
      | :--: | :----------------------------------------------------------: | :--: |
      |  1   | 传递 Instr、PC、WD2、ALUResult、EXTResult、MemReadData、HI、LO |  -   |




- Controller

  - 端口说明
    | 序号 |     信号名      | 方向 |                             描述                             |
    | :--: | :-------------: | :--: | :----------------------------------------------------------: |
    |  1   |   Instr[31:0]   |  I   |                       32 位 MIPS 指令                        |
    |  2   |     rs[4:0]     |  O   |                              -                               |
    |  3   |     rt[4:0]     |  O   |                              -                               |
    |  4   |     rd[4:0]     |  O   |                              -                               |
    |  5   |   shamt[4:0]    |  O   |                              -                               |
    |  6   |   Imm16[15:0]   |  O   |                              -                               |
    |  7   |   Imm26[25:0]   |  O   |                              -                               |
    |  8   | ALUControl[2:0] |  O   |      ALU 控制信号，确定 ALU 执行的功能，端口说明见 ALU       |
    |  9   |    MemWrite     |  O   |                          DM 写信号                           |
    |  10  |    RegWrite     |  O   |                          GRF 写信号                          |
    |  11  |  Mem2Reg[2:0]   |  O   | GRF 写入数据的选择信号<br>3'b0：ALU 运算结果<br>3'b1：Memory[Addr]<br>3'b10：EXT 运算结果<br>3'b11：PC + 4 |
    |  12  | EXTControl[1:0] |  O   | EXT 扩展方式选择信号<br>2'b00：零扩展<br>2'b01：符号扩展<br>2'b10：低 16 位零扩展 |
    |  13  |     ALUSrc      |  O   | ALU 的第二个操作数选择信号<br>1'b0：RD2<br>1'b1：EXT 扩展的立即数 |
    |  14  |  RegAddr[4:0]   |  O   |                         寄存器写地址                         |
    |  11  | MDUControl[3:0] |  O   | 乘除法选择信号<br>4'b0000：递增<br>3'b001：beq 指令跳转<br>3'b010：j 指令跳转<br>3'b011：GRF[rs] |
    |  12  |  SControl[3:0]  |  O   |                     store 类指令位宽选择                     |
    |  13  |  LControl[3:0]  |  O   |                     load 类指令位宽选择                      |
    |  14  |     calc_r      |  O   |                                                              |
    |  15  |     calc_i      |  O   |                                                              |
    |  16  |       beq       |  O   |                      当前指令是否为 beq                      |
    |  17  |      bgtz       |  O   |                     当前指令是否为 bgtz                      |
    |  18  |       jal       |  O   |                      当前指令是否为 jal                      |
    |  19  |       jr        |  O   |                      当前指令是否为 jr                       |
    |  20  |      load       |  O   |                  当前指令是否为 load 类指令                  |
    |  21  |      store      |  O   |                 当前指令是否为 store 类指令                  |
    |  22  |       lui       |  O   |                      当前指令是否为 lui                      |
    |  23  |       md        |  O   |                    当前指令是否为乘除指令                    |
    |  24  |       mf        |  O   |                   当前指令是否为 mfhi/mflo                   |
    |  25  |       mt        |  O   |                   当前指令是否为 mthi/mtlo                   |
  - 功能定义
    | 序号 |       功能        | 描述 |
    | :--: | :---------------: | :--: |
    |  1   | 产生 ALU 控制信号 |  -   |
    |  2   | 产生 GRF 控制信号 |  -   |
    |  3   | 产生 DM 控制信号  |  -   |
    |  4   | 产生 EXT 控制信号 |  -   |
    |  5   | 产生 IFU 控制信号 |  -   |
    |  6   | 输出当前指令类型  |  -   |





# 思考题

## 乘除模块

思考题

1、为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？

> ① ALU 模块为组合逻辑，乘除法部件为时序逻辑，运用单独的乘除法部件可以避免逻辑的混乱。
>
> ② 乘除法运算时序开销大，在程序中的模拟分别为5周期、10周期，整合进 ALU 会影响关键路径。将乘除法部件独立，可以在乘除法运算的周期执行其他指令，提高 CPU 整体效率。



2、真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。

> 通过多次加法实现乘法，每次加法均在上一次加法的结果（部分积）的高位部分进行，且根据乘数的最低位决定在加被乘数或加零;
> 每完成一次加法，结果（部分积）和乘数均右移1位
>
> 循环n次



3、请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？

> ```
>             case (MDUControl)
>                 4'd1: begin 
>                     Busy <= 1'b1;
>                     count <= 4'd5;
>                     {temp_hi, temp_lo} <= $signed(SrcA) * $signed(SrcB);
>                 end
>                 4'd2: begin
>                     Busy <= 1'b1;
>                     count <= 4'd5;
>                     {temp_hi, temp_lo} <= SrcA * SrcB;
>                 end
>                 4'd3: begin
>                     Busy <= 1'b1;
>                     count <= 4'd10;
>                     temp_hi <= $signed(SrcA) % $signed(SrcB);
>                     temp_lo <= $signed(SrcA) / $signed(SrcB);
>                 end
>                 4'd4: begin
>                     Busy <= 1'b1;
>                     count <= 4'd10;
>                     temp_hi <= SrcA % SrcB;
>                     temp_lo <= SrcA / SrcB;
>                 end
> ```
>
> 在 E 级指令为乘除运算时将 Busy 置高，在 count 递减到 0 时，置 Busy 为 0；若非乘除运算则保持 Busy 为初始 0 不变。即只有乘除指令时置高 Busy，乘除指令结束后马上置 Busy 为 0。
>
> ```
>         else if (count == 4'b1) begin
>             HI <= temp_hi;
>             LO <= temp_lo;
>             count <= 4'b0;
>             Busy <= 1'b0;
>         end



## 支持按字节访存

思考题

4、请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）

> 清晰性：当前指令的使能情况一目了然，不用再对 StoreControl 信号进行处理
>
> 统一性：使三种写指令都有统一的处理方式，不用再对每种写指令分开处理



5、请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？

> 按字节读：获得的数据可以理解为“一字节”
>
> 按字节写：先读出源数据，再将整字替换对应字节，写入字，所以不是一字节
>
> 对单个字节内存频繁操作时（如 C 语言中对 char 类型数据的操作，字符串处理类等）



## 复杂性控制

思考题

6、为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？

> 抽象：将同类型指令归并为一类，如设置了 load 变量表示读取指令，赋值为 lw | lh | lb，store 变量表示存储指令，calc_r 表示 r 类型运算指令，calc_i 表示 i 类型运算指令，md 表示乘除指令，mf 表示 mfhi | mflo，mt 表示 mthi | mtlo指令
>
> ```
> parameter zero = 3'b000, sign = 3'b001, upper = 3'b010; 
> 
> load = lw | lh | lb;
> calc_r = add | sub | ...
> EXTControl = (load | store | addi) ? sign : 
> 			 (lui) ? upper :
> 			 zero;
> ```
>
> 规范：设置宏定义，模块化，变量规范命名
>
> ```
> // D_REG.v
> wire D_RegAddr[4:0];
> wire E_check;
> ```
>
> 特点与帮助：使得繁杂的工作变得有迹可循，有效提升了编码时的效率和正确性



## 在线测试

思考题

7、在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？

```
#b calc_r 
ori $1 $0 12 
add $1 $1 $0 
beq $1 $0 next1

#b calc_i 
ori $2 $0 12 
beq $2 $0 next2

#b load 
ori $3 $0 12
sw $3 0($0) 
lw $4 0($0) 
beq $4 $0 next3

#calc_r load 
ori $1 $0 12 
sw $1 0($0) 
lw $2 0($0) 
sub $3 $2 $1 

#cal_i load 
ori $1 $0 12 
sw $1 0($0) 
lw $2 0($0) 
ori $3 $2 0

#store load store
ori $1 $0 12 
sw $1 0($0) 
lw $2 0($0) 
sw $2 0($2) 

#jr calc_r 
ori $1 $0 0x3010
add $1 $1 $0
jr $1

#jr calc_i 
ori $1 $0 0x3010 
jr $1

#jr load 
ori $1 $0 0x3014 
sw $1 0($0) 
lw $2 0($0) 
jr $2
```

> 利用 AT 法，将满足 AT 条件的冲突通过转发解决，不能转发解决的通过暂停解决



8、如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证**覆盖**了所有需要测试的情况；如果你是**完全随机**生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了**特殊的策略**，比如构造连续数据冒险序列，请你描述一下你使用的策略如何**结合了随机性**达到强测的效果。

> 构造策略：按指令类型和 $T_{use}$ 、$T_{new}$ 等枚举冲突
>
> <img src="D:\Programing\ComputerOrganization\P6\1.jpg" style="zoom: 50%;" />
>
> <img src="D:\Programing\ComputerOrganization\P6\2.jpg" style="zoom:50%;" />
