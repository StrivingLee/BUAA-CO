# P7 设计文档

[TOC]

# 设计草稿

## 一、设计与测试说明

1. 处理器为 32 位五级流水线处理器

2. 支持延迟槽

3. 支持如下指令集：

   ```mipsasm
   add, sub, and, or, slt, sltu, lui
   addi, andi, ori
   lb, lh, lw, sb, sh, sw
   mult, multu, div, divu, mfhi, mflo, mthi, mtlo
   beq, bne, jal, jr
   mfc0, mtc0, eret, syscall
   ```

5. 采用全速转发的设计

6. 转发的数据来源为流水线寄存器

7. 采用模块化和层次化设计，顶层文件为 mips.v，接口定义如下：

   ```verilog
   module mips(
       input clk,                    // 时钟信号
       input reset,                  // 同步复位信号
       input interrupt,              // 外部中断信号
       output [31:0] macroscopic_pc, // 宏观 PC
   
       output [31:0] i_inst_addr,    // IM 读取地址（取指 PC）
       input  [31:0] i_inst_rdata,   // IM 读取数据
   
       output [31:0] m_data_addr,    // DM 读写地址
       input  [31:0] m_data_rdata,   // DM 读取数据
       output [31:0] m_data_wdata,   // DM 待写入数据
       output [3 :0] m_data_byteen,  // DM 字节使能信号
   
       output [31:0] m_int_addr,     // 中断发生器待写入地址
       output [3 :0] m_int_byteen,   // 中断发生器字节使能信号
   
       output [31:0] m_inst_addr,    // M 级 PC
   
       output w_grf_we,              // GRF 写使能信号
       output [4 :0] w_grf_addr,     // GRF 待写入寄存器编号
       output [31:0] w_grf_wdata,    // GRF 待写入数据
   
       output [31:0] w_inst_addr     // W 级 PC
   );
   ```





## 二、整体结构

### 模块规格

该部分我们不再介绍P6中已经实现的模块，只介绍新增模块CPU（封装P6CPU），CP0，Bridge，TC（用于实例化Timer0，Timer1）。但是原有模块需要根据异常处理的实现需要进行微调。

- CPU
  - 端口说明
  
    |     信号名      | 方向 |                            描述                            |
    | :-------------: | :--: | :--------------------------------------------------------: |
    |       clk       |  I   |                          时钟信号                          |
    |      reset      |  I   |          同步复位信号<br>1'b1：清零<br>1'b0：保持          |
    | HWInt[5:0] | I | 传递来自计时器和外部的中断信号 |
    | macroscopic_pc[31:0] | O | 宏观 PC |
    | i_inst_addr[31:0] | O | 取指地址 |
    |     i_inst_rdata[31:0]     |  I  |          取出指令     |
    | m_data_addr[31:0] | O | 与外设交互的地址 |
    | m_data_rdata[31:0] | I | 从外设读入的数据 |
    | m_data_wdata[31:0] | O | 向外设写入的数据 |
    | m_data_byteen[31:0] | O | CPU 输出的字节使能信号 |
    | m_inst_addr[31:0] | O | M 级指令地址 |
    | w_grf_we | O | W 级寄存器写使能 |
    | w_grf_addr[4:0] | O | W 级寄存器写入地址 |
    | w_grf_wdata[31:0] | O | W 级寄存器写入数据 |
    | w_inst_addr[31:0] | O | W 级指令地址 |
    | IntResponse | O | 对中断的响应信号 |
    
    多出的端口 `HWInt` 和 `IntResponse` 分别用来接收中断和方便测试。




- Bridge

    - 端口说明
    
      |         信号名          | 方向 |                    描述                    |
      | :---------------------: | :--: | :----------------------------------------: |
      |    m_data_addr[31:0]    |  O   |           M 级**最终**的写入地址           |
      |   m_data_rdata[31:0]    |  I   |           CPU 输出的 M 级读数据            |
      |   m_data_wdata[31:0]    |  O   | CPU **最终**向外设写入的数据（与最初相等） |
      |   m_data_byteen[3:0]    |  O   |    **最终**写回 CPU 的外设字节使能信号     |
      |  cpu_m_data_addr[31:0]  |  I   |          CPU 输出的 M 级写入地址           |
      | cpu_m_data_rdata[31:0]  |  O   |       **最终**写回 CPU 的 M 级读数据       |
      | cpu_m_data_wdata[31:0]  |  O   |          CPU 输出的 M 级写入数据           |
      | cpu_m_data_byteen[31:0] |  I   |           CPU 输出的字节使能信号           |
      |    m_int_addr[31:0]     |  O   |            中断发生器待写入地址            |
      |    m_int_byteen[3:0]    |  O   |           中断发生器字节使能信号           |
      |     TC0_Addr[31:0]      |  O   |             Timer0 的写入地址              |
      |         TC0_WE          |  O   |            Timer0 的写使能信号             |
      |      TC0_Din[31:0]      |  O   |             Timer0 的写入数据              |
      |     TC0_Dout[31:0]      |  I   |             Timer0 的输出数据              |
      |     TC1_Addr[31:0]      |  O   |             Timer1 的写入地址              |
      |         TC1_WE          |  O   |            Timer1 的写使能信号             |
      |      TC1_Din[31:0]      |  O   |             Timer1 的写入数据              |
      |     TC1_Dout[31:0]      |  I   |             Timer1 的输出数据              |
    
      
    

- CP0

  - 端口说明

    | 序号 |     信号名     | 方向 |                         描述                          |
    | :--: | :------------: | :--: | :---------------------------------------------------: |
    |  1   |      Zero      |  I   |                 ALU 运算结果是否为 0                  |
    |  2   |  GreaterZero   |  I   | SrcA 是否 > 0的标志信号，接收 ALU 的 GreaterZero 信号 |
    |  3   |      beq       |  I   |                  当前指令是否为 beq                   |
    |  4   |      bne       |  I   |                  当前指令是否为 bne                   |
    |  4   |      bgtz      |  I   |                  当前指令是否为 bgtz                  |
    |  5   |      jal       |  I   |                  当前指令是否为 jal                   |
    |  6   |       jr       |  I   |                   当前指令是否为 jr                   |
    |  7   |   F_PC[31:0]   |  I   |                    接收 F_PC 信号                     |
    |  8   |   D_PC[31:0]   |  I   |                    接收 D_PC 信号                     |
    |  8   |  Imm26[25:0]   |  I   |              接收 Splitter 的 Imm26 信号              |
    |  9   | EXTImm32[31:0] |  I   |               接收 EXT 的 EXTImm32 信号               |
    |  10  | GRF[rs]\[31:0] |  I   |                   接收 GRF[rs] 的值                   |
    |  11  |   NPC[31:0]    |  O   |                Next PC，下一条指令计数                |
  
  - 功能定义
  
    | 序号 |   功能   |          描述           |
    | :--: | :------: | :---------------------: |
    |  1   | 计算 NPC | 根据NPCControl 计算 NPC |





# 思考题



1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？

> 鼠标和键盘等外设并不是直接与CPU相连的，中间需要通过软件来连接，这个软件也就是我们熟知的驱动。驱动和硬件之间通过操作系统进行处理。最终 CPU 进入中断处理区的对应位置，处理输入信号。



2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）

> 不能提供所希望的功能。
>
> 事实上 CPU 只能处理常数信息，设置固定的地址 CPU 才能正确进行访问。用户给出变量地址的中断异常程序，试想计算该跳转地址时发生异常，用户自定义入口地址的处理中断异常程序便无法正常运行。



3、为何与外设通信需要 Bridge？

> CPU 的功能是复杂的，接口是简单的。如果将“与多种外设对接”的复杂接口也加给 CPU，那么 CPU 就会过于复杂。
>
> 因此我们设置 Bridge 系统桥承担将复杂接口归并为简单接口的任务。
>
> 这样 CPU 就可以和多种多样的外设对接，而只需要暴露简单的接口即可，不需要显示和处理其他细节，体现了"高内聚，低耦合"原则。



4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。

> 



5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？

> 此时宏观 PC 会显示为 0，和单周期封装相矛盾。此外，延迟槽标记信号 BD 也会出现问题。如果是中断或者异常指令造成的流水线清空，应该保持原有的PC值，以保证宏观PC的正确。如果是阻塞造成的DE级流水线清除，应该要保持原有的PC并且保持原有的BD标志信号。



6、为什么 `jalr` 指令为什么不能写成 `jalr $31, $31`？

> ```
>Register specifiers rs and rd must not be equal, because such an instruction does not have the same effect when re-executed. The result ofexecuting such an instruction is UNPREDICTABLE. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot
> ```
> 
> 指令集要求。寄存器说明符 rs 和 rd 不得相等，因为此类指令在重新执行时不具有相同的效果。执行此类指令的结果是不可预测的。此限制允许异常处理程序在分支延迟槽中发生异常时通过重新执行分支来恢复执行。
